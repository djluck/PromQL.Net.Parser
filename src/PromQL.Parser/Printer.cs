using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using PromQL.Parser.Ast;

namespace PromQL.Parser
{
    /// <summary>
    /// Converts PromQL Abstract Syntax Tress (AST's) into a string representation.
    /// </summary>
    /// <remarks>
    /// Instances of this class are <i>not</i> thread safe and so should not be shared between threads.
    /// </remarks>
    public class Printer : IVisitor
    {
        private readonly PrinterOptions _options;
        private readonly IndentedStringBuilder _sb;

        /// <summary>
        /// Initializes a new printer instance.
        /// </summary>
        /// <param name="options">Allows customization of the output generated by the printer. Defaults to <see cref="PrinterOptions.PrettyDefault"/>.</param>
        public Printer(PrinterOptions? options = null)
        {
            _options = options ?? PrinterOptions.PrettyDefault;
            _sb = new IndentedStringBuilder(_options.IndentChar, _options.IndentCount);
        }

        public virtual void Visit(StringLiteral s)
        {
            // Raw strings are denoted by ` and should not have their values escaped
            if (s.Quote == '`')
            {
                Write($"{s.Quote}{s.Value}{s.Quote}");
                return;
            }
            
            // TODO this both duplicates knowledge in the Parser and is inefficient, can do better
            var escaped = s.Value
                .Replace("\\", "\\\\")
                .Replace($"{s.Quote}", $"\\{s.Quote}")
                .Replace("\a", "\\a")
                .Replace("\b", "\\b")
                .Replace("\f", "\\f")
                .Replace("\n", "\\n")
                .Replace("\r", "\\r")
                .Replace("\t", "\\t")
                .Replace("\v", "\\v");
            
            Write($"{s.Quote}{escaped}{s.Quote}");
        }

        public virtual void Visit(SubqueryExpr sq)
        {
            sq.Expr.Accept(this);
            Write("[");
            sq.Range.Accept(this);
            Write(":");
            sq.Step?.Accept(this);
            Write("]");
        }

        public virtual void Visit(Duration d)
        {
            if (d.Value.Days > 0)
                Write($"{d.Value.Days}d");
            if (d.Value.Hours > 0)
                Write($"{d.Value.Hours}h");
            if (d.Value.Minutes > 0)
                Write($"{d.Value.Minutes}m");
            if (d.Value.Seconds > 0)
                Write($"{d.Value.Seconds}s");
            if (d.Value.Milliseconds > 0)
                Write($"{d.Value.Milliseconds}ms");
        }

        public virtual void Visit(NumberLiteral n) => Write(n.Value switch
        {
            double.PositiveInfinity => "Inf",
            double.NegativeInfinity => "-Inf",
            _ => n.Value.ToString()
        });

        public virtual void Visit(MetricIdentifier mi) => Write(mi.Value);

        public virtual void Visit(LabelMatcher lm)
        {
            Write($"{lm.LabelName}{lm.Operator.ToPromQl()}");
            lm.Value.Accept(this);
        }

        public virtual void Visit(LabelMatchers lms)
        {
            bool first = true;
            Write("{");
            foreach (var lm in lms.Matchers)
            {
                if (!first)
                    Write(", ");
                
                lm.Accept(this);
                first = false;
            }
            Write("}");
        }

        public virtual void Visit(VectorSelector vs)
        {
            vs.MetricIdentifier?.Accept(this);
            vs.LabelMatchers?.Accept(this);
        }

        public virtual void Visit(UnaryExpr unary)
        {
            Write(unary.Operator.ToPromQl());
            unary.Expr.Accept(this);
        }

        public virtual void Visit(MatrixSelector ms)
        {
            ms.Vector.Accept(this);
            Write("[");
            ms.Duration.Accept(this);
            Write("]");
        }

        public virtual void Visit(OffsetExpr offset)
        {
            offset.Expr.Accept(this);
            Write(" offset ");

            Duration d = offset.Duration;

            if (d.Value < TimeSpan.Zero)
            {
                // Negative durations cannot be printed by the duration visitor. Convert to positive and emit sign here.
                d = d with { Value = new TimeSpan(Math.Abs(d.Value.Ticks))};
                Write("-");
            }
            
            d.Accept(this);
        }

        public virtual void Visit(ParenExpression paren)
        {
            Write("(");

            using (_options.BreakOnParenExpr ? _sb.IncreaseIndent() : null)
                paren.Expr.Accept(this);
            
            Write(")");
        }

        public virtual void Visit(FunctionCall fnCall)
        {
            Write($"{fnCall.Function.Name}(");

            bool isFirst = true;
            foreach (var arg in fnCall.Args)
            {
                if (!isFirst)
                    Write(", ");
                
                arg.Accept(this);
                isFirst = false;
            }
            
            Write(")");
        }

        public virtual void Visit(VectorMatching vm)
        {
            if (vm.ReturnBool)
            {
                Write("bool");
            }

            if (vm.On || vm.MatchingLabels.Length > 0)
            {
                if (vm.ReturnBool)
                    Write(" ");
                
                Write(vm.On ? "on" : "ignoring");
                Write(" (");
                Write(string.Join(", ", vm.MatchingLabels));
                Write(")");
            }

            if (vm.MatchCardinality != VectorMatching.DefaultMatchCardinality)
            {
                if (_sb.Length > 0)
                    Write(" ");
                
                Write(vm.MatchCardinality.ToPromQl()!);
            }

            if (vm.Include.Length > 0 || vm.MatchCardinality != VectorMatching.DefaultMatchCardinality)
            {
                if (_sb.Length > 0)
                    Write(" ");
                
                Write("(");
                Write(string.Join(", ", vm.Include));
                Write(")");
            }
        }

        public virtual void Visit(BinaryExpr expr)
        {
            expr.LeftHandSide.Accept(this);
            
            if (_options.BreakOnBinaryOperators)
                _sb.AppendLine();
            else
                Write(" ");
            
            Write($"{expr.Operator.ToPromQl()} ");

            var preLen = _sb.Length;
            expr.VectorMatching?.Accept(this);

            if (_sb.Length > preLen)
                Write(" ");
            
            expr.RightHandSide.Accept(this);
        }

        public virtual void Visit(AggregateExpr expr)
        {
            Write($"{expr.Operator.Name}");

            if (expr.GroupingLabels.Length > 0)
            {
                Write(" ");
                Write(expr.Without ? "without" : "by");
                Write($" ({string.Join(", ", expr.GroupingLabels)}) ");
            }

            Write("(");
            if (expr.Param != null)
            {
                expr.Param.Accept(this);
                Write(", ");
            }

            expr.Expr.Accept(this);
            Write(")");
        }

        protected void Write(string s)
        {
           _sb.Append(s);
        }

        public string ToPromQl(IPromQlNode node)
        {
            if (node == null)
                throw new ArgumentNullException();
            
            _sb.Clear();
            node.Accept(this);

            return _sb.ToString()!;
        }
    }

    internal class IndentedStringBuilder
    {
        private int _indentLevel = 0;
        private readonly string[] _indents;
        private const int MaxIndent = 20;
        private StringBuilder _sb = new StringBuilder();
        
        public IndentedStringBuilder(char indentChar, int indentCount)
        {
            _indents = Enumerable.Range(0, MaxIndent)
                .Select(n => new string(Enumerable.Repeat(indentChar, indentCount * n).ToArray()))
                .ToArray();
        }

        public void Append(string? s) => _sb.Append(s);

        public int Length => _sb.Length;

        public void Clear() => _sb.Clear();

        public void AppendLine()
        {
            _sb.AppendLine();
            _sb.Append(_indents[_indentLevel]);
        }

        public override string ToString() => _sb.ToString();

        public IDisposable IncreaseIndent()
        {
            _indentLevel++;
            if (_indentLevel == MaxIndent)
                throw new InvalidOperationException($"Cannot increase indent beyond {MaxIndent}");

            AppendLine();
            return new DisposableIndent(this);
        }

        public void DecreaseIndent()
        {
            _indentLevel--;
            AppendLine();
        }

        internal class DisposableIndent : IDisposable
        {
            private readonly IndentedStringBuilder _isb;
            private bool _disposed;

            public DisposableIndent(IndentedStringBuilder isb)
            {
                _isb = isb;
                _disposed = false;
            }

            public void Dispose()
            {
                if (_disposed)
                    return;
                
                _isb.DecreaseIndent();
                _disposed = true;
            }
        }
    }

    public record PrinterOptions(
        int IndentCount,
        char IndentChar,
        bool BreakOnParenExpr,
        bool BreakOnBinaryOperators
    )
    {
        /// <summary>
        /// Formats the printed output of PromQL expressions into a more human-readable format,
        /// by inserting line breaks and indentation. 
        /// </summary>
        public static PrinterOptions PrettyDefault = new(2, ' ', true, true);
        
        /// <summary>
        /// Doesn't format the printed output of PromQL expressions.
        /// </summary>
        public static PrinterOptions NoFormatting = new(0, ' ', false, false);
    }
}